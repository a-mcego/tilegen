import numpy as np
from collections import deque
from PIL import Image
import time

#takes a tilemap generated by make_tiles.py and generates a new map

GEN_SIZE = np.array([32,32])
FILENAME = "output.png"

#save state every BACKTRACK_SAVE_TIME tiles generated
#here we use the square root of the area in tiles
BACKTRACK_SAVE_TIME = np.sqrt(np.multiply(GEN_SIZE[0],GEN_SIZE[1]).astype(np.float32)).astype(np.int64)

#how many times to retry backtracking from a specific point
#after this, fall back to an earlier state
MAX_RETRY_COUNT = 16

def remove_if(tensor, condition):
    tensor_processed = []
    for x in range(condition.shape[0]):
        if condition[x]:
            continue
        tensor_processed.append(tensor[x])
    return np.stack(tensor_processed)

def gen_neighbors(this_indices, neighbor_indices, empty_index, max_index):
    tensor = np.stack([this_indices,neighbor_indices],axis=-1)
    tensor = np.reshape(tensor,[-1,tensor.shape[-1]])
    #TODO: maybe return the counts too?
    tensor = np.unique(tensor, axis=0)
    cull = np.logical_or.reduce(np.isin(tensor,empty_index),axis=-1)
    tensor = remove_if(tensor,cull)
    possibilities = np.zeros(shape=[max_index+1,max_index+1])
    for index in range(tensor.shape[0]):
        possibilities[tensor[index,0],tensor[index,1]] += 1
    return possibilities

filename = "pokemon_firered_leafgreen.png.npz"

stuff = np.load(filename)
tiles = stuff['tiles']
indices = stuff['indices']

empty_index = indices[0,0]
max_index = np.amax(indices)

n_up = gen_neighbors(indices[1:,:],indices[:-1,:], empty_index, max_index)
n_down = gen_neighbors(indices[:-1,:],indices[1:,:], empty_index, max_index)
n_left = gen_neighbors(indices[:,1:],indices[:,:-1], empty_index, max_index)
n_right = gen_neighbors(indices[:,:-1],indices[:,1:], empty_index, max_index)
neighbors = np.stack([n_up, n_down, n_left, n_right])

rowsums = np.sum(neighbors,axis=-1)
badrows = []
for n in range(rowsums.shape[0]):
    for r in range(rowsums.shape[1]):
        if rowsums[n,r] == 0:
            badrows.append(r)
if len(badrows) > 0:
    badrows = np.unique(badrows)
    print(f"Warning: {badrows.shape[0]} tile types with no neighbors in at least one direction!")

num_tiles = tiles.shape[0]

valid = np.ones([GEN_SIZE[0],GEN_SIZE[1],num_tiles],dtype=np.uint8)
done = np.zeros(GEN_SIZE, dtype=np.int64)

neighbor_indices = np.array([[-1,0],[1,0],[0,-1],[0,1]])+GEN_SIZE
np.set_printoptions(suppress=True)

starttime = time.time()

class BacktrackSaver:
    def __init__(self):
        self.valids = []
        self.dones = []
        self.retries = [] #how many times we've retried from this point

    def save(self, valid, done):
        self.valids.append(np.array(valid))
        self.dones.append(np.array(done))
        self.retries.append(0)

    def load(self):
        self.retries[-1] += 1
        while self.retries[-1] >= MAX_RETRY_COUNT and len(self.retries) > 1:
            self.valids.pop()
            self.dones.pop()
            self.retries.pop()
            self.retries[-1] += 1
        print("CONTRADICTION! Loading", np.sum(self.dones[-1]))
        return self.valids[-1],self.dones[-1]

btsaver = BacktrackSaver()

while np.all(done) != True:
    done_tiles = np.sum(done)
    print(f"{round(time.time()-starttime,2)} {done_tiles} / {GEN_SIZE[0]*GEN_SIZE[1]}")
    if done_tiles%BACKTRACK_SAVE_TIME == 0:
        btsaver.save(valid,done)

    weights = np.multiply(np.sum(valid,axis=-1),1.0-done.astype(np.float32))
    position_choice = np.unravel_index(np.argmin(weights+done*1000000),shape=GEN_SIZE)
    #check for contradiction :blobhiki:
    if np.amax(valid[position_choice]) == 0:
        valid,done = btsaver.load()
        continue

    logits = np.log(valid[position_choice].astype(np.float32)+1e-9)
    gumbel_z = np.random.gumbel(size=logits.shape)
    gumbel_sum = logits+gumbel_z
    type_choice = np.argmax(gumbel_sum)
    valid[position_choice] = np.zeros_like(valid[position_choice])
    valid[position_choice[0],position_choice[1],type_choice] = True
    done[position_choice] = True

    elem = np.asarray(position_choice)
    position_queue = deque([elem])

    while len(position_queue) > 0:
        current_elem = np.asarray(position_queue.popleft())
        neighboring_elements = np.mod(current_elem+neighbor_indices,GEN_SIZE)
        current_elem_vector = valid[current_elem[0],current_elem[1]]
        for neighbor_index in range(neighboring_elements.shape[0]):
            new_elem = neighboring_elements[neighbor_index]
            if done[new_elem[0],new_elem[1]]:
                continue
            new_elem_vector = valid[new_elem[0],new_elem[1]]
            result_matrix = np.logical_and(np.logical_and(current_elem_vector[:,np.newaxis],new_elem_vector[np.newaxis,:]),neighbors[neighbor_index])
            nev = np.any(result_matrix, axis=0)
            has_not_changed = np.array_equal(new_elem_vector,nev)
            if has_not_changed:
                continue
            valid[new_elem[0],new_elem[1]] = nev
            position_queue.append(new_elem)

output = np.argmax(valid,axis=-1)
output_shape = output.shape
output_image = np.take(tiles,np.reshape(output,[-1]),axis=0)
output_image = np.reshape(output_image,[GEN_SIZE[0],GEN_SIZE[1],output_image.shape[-3],output_image.shape[-2],output_image.shape[-1]])
output_image = np.transpose(output_image,[0,2,1,3,4])
output_image = np.reshape(output_image,[output_image.shape[0]*output_image.shape[1],output_image.shape[2]*output_image.shape[3],output_image.shape[-1]])

im = Image.fromarray(output_image)
im.save(FILENAME)
print("All done and saved! :D")
